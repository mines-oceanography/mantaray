
#[derive(Debug, thiserror::Error)]
pub enum Error {
   #[error("Undefined error")]
   Undefined,
   #[error("Argument passed was out of bounds")]
   ArgumentOutOfBounds
}

// TODO: have this function accept stepper as an argument
use std::io::Write;
fn output_to_file(system: WaveRayPath, t0: f64, y0: State, tf: f64, step_size: f64) -> Result<File, Error> {

   let mut stepper = Rk4::new(system, t0, y0, tf, step_size);
   let res = stepper.integrate();
   if let Err(_) = res {
      return Err(Error::Undefined);
   }
   let y = stepper.y_out();
   
   let mut file = File::create("y_out.txt").expect("could not open file");
   writeln!(&mut file, "t x y kx ky").expect("could not write to file");
   for (i, x) in stepper.x_out().iter().enumerate() {
      write!(&mut file, "{x} ").expect("could not write to file");
      for elem in y[i].iter() {
         write!(&mut file, "{elem} ").expect("could not write to file");
      }
      writeln!(&mut file, " ").expect("could not write to file");
   }
   Ok(file)

}

trait Depth {
    fn calculate(&self, x: f64, y: f64) -> f64;
}

impl<'a> WaveRayPath<'a> {
   pub fn new(gravity: f64, depth_data: &'a Box<dyn Depth>) -> Self {
      WaveRayPath { g: gravity, data: depth_data }
   }
   pub fn depth(&self, x: f64, y: f64) -> f64 {
      self.data.calculate(x, y)
   }
}

struct ConstantDepth {
   d: f64,
}

impl Depth for ConstantDepth {
   fn calculate(&self, _x: f64, _y: f64) -> f64 {
       self.d
   }
}

struct ArrayDepth {
   array: Vec<Vec<f64>>,
}

// FIXME: the program is not crashing, but NAN isn't that useful. maybe use option: some or none
impl Depth for ArrayDepth {
   fn calculate(&self, x: f64, y: f64) -> f64 {
      if x as usize >= self.array.len() || y as usize >= self.array.len() {
         return f64::NAN;
      }
       self.array[x as usize][y as usize] // FIXME: since x and y are floats, they are truncated or rounded to a usize. I probably want a better interpolation estimate
   }
}


/// This function takes in the states and returns group velocity:
/// 
/// returns no current, constant h, general equation
/// 
 pub fn group_velocity(k: f64, d: f64) -> Result<f64, Error> {
   if d < 0.0 {
      return Ok(f64::NAN); // FIXME: should this also return an error?
   }
   if k <= 0.0 {
      return Err(Error::ArgumentOutOfBounds);
   }
   let g = 9.8; // relocate this?
   Ok( (g / 2.0) * ( ((k*d).tanh() + (k*d)/(k*d).cosh().powi(2)) / (k*g*(k*d).tanh()).sqrt() ) ) // TODO: test with deep and shallow water cases
 }

 /// Takes current state and calculates derivatives
 /// 
 /// returns the odes
 ///  
 pub fn odes(kx: f64, ky: f64, h: f64) -> (f64, f64, f64, f64) {

    let k_mag = (kx*kx + ky*ky).sqrt();
    let k_dir = ky.atan2(kx);

    let cg = group_velocity(k_mag, h).unwrap();
    let cgx = cg * k_dir.cos();
    let cgy = cg * k_dir.sin();

    let dxdt = cgx;
    let dydt = cgy;

    let dkxdt = 0.0;
    let dkydt = 0.0;

    (dxdt, dydt, dkxdt, dkydt)
 }


use std::fs::File;

use ode_solvers::*;

type State = Vector4<f64>;
type Time = f64;

struct WaveRayPath<'a> {
   g: f64,
   data: &'a Box<dyn Depth>,
}

impl<'a> ode_solvers::System<State> for WaveRayPath<'a> {
   fn system(&self, x: Time, y: &State, dy: &mut State) {
      let d = self.depth(y[0], y[1]);
       let (dxdt, dydt, dkxdt, dkydt) = odes(y[2], y[3], d);
       
       dy[0] = dxdt;
       dy[1] = dydt;
       dy[2] = dkxdt;
       dy[3] = dkydt;
   }
}


#[cfg(test)]
mod test_constant_cg {

   use crate::{group_velocity, odes, ConstantDepth, ArrayDepth, output_to_file, Depth};

   // testing group velocity function against values generated by wolfram alpha
    #[test]
    fn test_group_velocity() {
      let results = [
         (1.0, 1.565247584249853),
         (3.0, 0.9036961141150639),
         (5.0, 0.7),
         (10.0, 0.4949747468305833)
      ];
      for (k, ans) in results {
         assert!((group_velocity(k, 1000.0).unwrap() - ans).abs() < 1.0e-4, "k: {}, ans: {}", k, ans);
      } 
    }

    #[test]
    fn test_negative_k() {
         assert!(group_velocity(-1.0, 1000.0).is_err());
         assert!(group_velocity(-12.0, 1000.0).is_err())
      }

   // testing ode on simple cases worked out by hand
   #[test]
   fn test_odes() {
      let results = [
         // (kx, ky, dxdt, dydt)
         (1.0, 0.0, 1.565247584249853, 0.0),
         (0.0, 1.0, 0.0, 1.565247584249853),
         (-1.0, 0.0, -1.565247584249853, 0.0),
         (0.0, -1.0, 0.0, -1.565247584249853),
         // (0.0, 0.0, 0.0, 0.0) // this would cause panic
      ];
      for (kx, ky, ans_dxdt, ans_dydt) in results {
         let (dxdt, dydt, _, _) = odes(kx, ky, 1000.0);
         assert!(
            (ans_dxdt - dxdt).abs() < 1.0e-4
            && (ans_dydt -dydt).abs() < 1.0e-4,
            "ans_dxdt: {}, ans_dydt: {}, dxdt: {}, dydt: {}, kx: {}, ky: {}",
            ans_dxdt, ans_dydt, dxdt, dydt, kx, ky
         );
      }
   }

   use crate::{State, WaveRayPath};
   use ode_solvers::*;

   #[test]
   #[should_panic]
   fn test_zero_k() {
      let data : Box<dyn Depth> = Box::new(ConstantDepth { d: 1000.0 });
      let system = WaveRayPath::new(9.8, &data);
      let y0 = State::new(0.0, 0.0, 0.0, 0.0);

      let t0 = 0.0;
      let tf = 10.0;
      let step_size = 1.0;

      let mut stepper = Rk4::new(system, t0, y0, tf, step_size);
      let res = stepper.integrate();
   }

   #[test]
   // Testing the ode_solvers Rk4 function only in the kx or ky direction
   fn test_axis() {
      let data : Box<dyn Depth> = Box::new(ConstantDepth { d: 1000.0 });
      // answers should be the square root of gravity
      let check_axis = [
         (0.0, 1.0, 0.0, (9.8_f64).sqrt()/2.0),
         (1.0, 0.0, (9.8_f64).sqrt()/2.0, 0.0),
         (0.0, -1.0, 0.0, -(9.8_f64).sqrt()/2.0),
         (-1.0, 0.0, -(9.8_f64).sqrt()/2.0, 0.0)
      ];
      for (kx, ky, xf, yf) in check_axis {
         let system = WaveRayPath::new(9.8, &data);
         let y0 = State::new(0.0, 0.0, kx, ky);
         let mut stepper = Rk4::new(system, 0.0, y0, 1.0, 1.0);
         if stepper.integrate().is_ok() {
            let last_state = stepper.y_out().last().unwrap();
            assert!(
               (last_state.x - xf).abs() < 3.0*f64::EPSILON // super close, so I will take the values it gives as accurate
               && (last_state.y - yf).abs() < 3.0*f64::EPSILON,
               "expected xf: {}, actual: {} \nexpected yf: {}, actual: {}",
               xf, last_state.x, yf, last_state.y
            );
         } else {
            panic!("Error during ode_solvers integration")
         }
      }
   }

   #[test]
   fn test_array_as_parameter() {
      // answers should be the square root of gravity divided by 2
      let check_axis = [
         (0.0, 1.0, 0.0, (9.8_f64).sqrt()/2.0),
         (1.0, 0.0, (9.8_f64).sqrt()/2.0, 0.0),
         (0.0, -1.0, 0.0, -(9.8_f64).sqrt()/2.0),
         (-1.0, 0.0, -(9.8_f64).sqrt()/2.0, 0.0)
      ];
      for (kx, ky, xf, yf) in check_axis {
         let data: Box<dyn Depth> = Box::new(ArrayDepth { array: vec![
            vec![1000.0, 1000.0],
            vec![1000.0, 1000.0]
         ] });
         let system = WaveRayPath::new(9.8, &data);

         let y0 = State::new(0.0, 0.0, kx, ky);
         let mut stepper = Rk4::new(system, 0.0, y0, 1.0, 1.0);
         if stepper.integrate().is_ok() {
            let last_state = stepper.y_out().last().unwrap();
            assert!(
               (last_state.x - xf).abs() < 3.0*f64::EPSILON // super close, so I will take the values it gives as accurate
               && (last_state.y - yf).abs() < 3.0*f64::EPSILON,
               "expected xf: {}, actual: {} \nexpected yf: {}, actual: {}",
               xf, last_state.x, yf, last_state.y
            );
         } else {
            panic!("Error during ode_solvers integration")
         }
      }
   }

   #[test]
   // if any of the input is NAN, the output should be none, even if k is zero
   fn test_nan() {
      let data : Box<dyn Depth> = Box::new(ConstantDepth { d: 1000.0 });
      let system = WaveRayPath::new(9.8, &data);
      let nan = f64::NAN;
      let y0 = State::new(0.0, nan, 0.0, 0.0);

      let t0 = 0.0;
      let tf = 1.0;
      let step_size = 1.0;

      let mut stepper = Rk4::new(system, t0, y0, tf, step_size);

      assert!(stepper.y_out().last().is_none());
   }

   #[test]
   // test when d / wavelenth < 1 / 20
   fn test_shallow() {
      let data : Box<dyn Depth> = Box::new(ConstantDepth { d: 0.1 });
      // answers should be the square root of gravity * h, but are not, they get closer as d approaches 0.
      let check_axis = [
         (0.0, 1.0, 0.0, 0.9850257444023037), // should be 0.9899494936611665
         (1.0, 0.0, 0.9850257444023037, 0.0),
         (0.0, -1.0, 0.0, -0.9850257444023037),
         (-1.0, 0.0, -0.9850257444023037, 0.0)
      ];
      for (kx, ky, xf, yf) in check_axis {
         let system = WaveRayPath::new(9.8, &data);
         let y0 = State::new(0.0, 0.0, kx, ky);
         let mut stepper = Rk4::new(system, 0.0, y0, 1.0, 1.0);
         if stepper.integrate().is_ok() {
            let last_state = stepper.y_out().last().unwrap();
            assert!(
               (last_state.x - xf).abs() < f64::EPSILON // super close, so I will take the values it gives as accurate
               && (last_state.y - yf).abs() < f64::EPSILON,
               "expected xf: {}, actual: {} \nexpected yf: {}, actual: {}",
               xf, last_state.x, yf, last_state.y
            );
         } else {
            panic!("Error during ode_solvers integration")
         }
      }
   }

   #[test]
   fn out_of_range_give_nan() {
      let data: Box<dyn Depth> = Box::new(ArrayDepth { array: vec![
         vec![1000.0, 1000.0],
         vec![1000.0, 1000.0]
      ] });
      let system = WaveRayPath::new(9.8, &data);
      let y0 = State::new(0.0, 0.0, 0.0, 1.0);
   
      let t0 = 0.0;
      let tf = 10.0;
      let step_size = 1.0;
   
      let mut stepper = Rk4::new(system, t0, y0, tf, step_size);
      let res = stepper.integrate();
   
      let last_step = stepper.y_out().last().unwrap();
   
      assert!(
         last_step.x.is_nan() && last_step.y.is_nan()
      );
   }

   #[test]
   // test writing a file
   fn write_file() {
      let data : Box<dyn Depth> = Box::new(ConstantDepth { d: 1000.0 });
      let system = WaveRayPath::new(9.8, &data);
      let y0 = State::new(0.0, 0.0, 1.0, -1.0);
   
      let t0 = 0.0;
      let tf = 10.0;
      let step_size = 1.0;
   
      assert!(output_to_file(system, t0, y0, tf, step_size).is_ok());
   }

}



#[derive(Debug, thiserror::Error)]
pub enum Error {
   #[error("Undefined error")]
   Undefined,
   #[error("Argument passed was out of bounds")]
   ArgumentOutOfBounds
}

/// This function takes in the states and returns group velocity:
/// 
/// returns simple case for now
/// 
/// FIXME: should return an Err result? right now just panics
 pub fn group_velocity(k: f64) -> Result<f64, Error> {
   if k <= 0.0 {
      return Err(Error::ArgumentOutOfBounds);
   }
   let g = 9.8; // relocate this?
   Ok((g/k).sqrt())
 }

 /// Takes current state and calculates derivatives
 /// 
 /// returns the odes
 ///  
 pub fn odes(kx: f64, ky: f64) -> (f64, f64, f64, f64) {

    let k_mag = (kx*kx + ky*ky).sqrt();
    let k_dir = ky.atan2(kx);

    let cg = group_velocity(k_mag).unwrap();
    let cgx = cg * k_dir.cos();
    let cgy = cg * k_dir.sin();

    let dxdt = cgx;
    let dydt = cgy;

    let dkxdt = 0.0;
    let dkydt = 0.0;

    (dxdt, dydt, dkxdt, dkydt)
 }

#[cfg(test)]
mod test_functions {
    use crate::{group_velocity, odes};

   // testing group velocity function against values generated by wolfram alpha
    #[test]
    fn test_group_velocity() {
      let results = [
         (1.0, 3.1305),
         (3.0, 1.80739),
         (5.0, 1.4),
         (10.0, 0.989949)
      ];
      for (k, ans) in results {
         assert!((group_velocity(k).unwrap() - ans).abs() < 1.0e-4, "k: {}, ans: {}", k, ans);
      } 
    }

    #[test]
    fn test_negative_k() {
         assert!(group_velocity(-1.0).is_err());
         assert!(group_velocity(-12.0).is_err())
      }

   // testing ode on simple cases worked out by hand
   #[test]
   fn test_odes() {
      let results = [
         // (kx, ky, dxdt, dydt)
         (1.0, 0.0, 3.13050, 0.0),
         (0.0, 1.0, 0.0, 3.13050),
         (-1.0, 0.0, -3.13050, 0.0),
         (0.0, -1.0, 0.0, -3.13050),
         // (0.0, 0.0, 0.0, 0.0) // this would cause panic
      ];
      for (kx, ky, ans_dxdt, ans_dydt) in results {
         let (dxdt, dydt, _, _) = odes(kx, ky);
         assert!(
            (ans_dxdt - dxdt).abs() < 1.0e-4
            && (ans_dydt -dydt).abs() < 1.0e-4,
            "ans_dxdt: {}, ans_dydt: {}, dxdt: {}, dydt: {}, kx: {}, ky: {}",
            ans_dxdt, ans_dydt, dxdt, dydt, kx, ky
         );
      }
   }

}


use ode_solvers::*;

type State = Vector4<f64>;
type Time = f64;

struct WaveRayPath {
   g: f64,
}

impl ode_solvers::System<State> for WaveRayPath {
   fn system(&self, x: Time, y: &State, dy: &mut State) {
       let (dxdt, dydt, dkxdt, dkydt) = odes(y[2], y[3]);
       
       dy[0] = dxdt;
       dy[1] = dydt;
       dy[2] = dkxdt;
       dy[3] = dkydt;
   }
}

#[cfg(test)]
mod test_ode_solver {
   use std::{fs::File, io::Write, io::{BufReader, BufRead}};

   use crate::{State, WaveRayPath};
   use ode_solvers::*;

   #[test]
   #[should_panic]
   fn zero_k() {
      let system = WaveRayPath { g: 9.8 };
      let y0 = State::new(0.0, 0.0, 0.0, 0.0);

      let t0 = 0.0;
      let tf = 10.0;
      let step_size = 1.0;

      let mut stepper = Rk4::new(system, t0, y0, tf, step_size);
      let res = stepper.integrate();
   }

   #[test]
   // Testing the ode_solvers Rk4 function only in the kx or ky direction
   fn test_axis() {
      // answers should be the square root of gravity
      let check_axis = [
         (0.0, 1.0, 0.0, (9.8_f64).sqrt()),
         (1.0, 0.0, (9.8_f64).sqrt(), 0.0),
         (0.0, -1.0, 0.0, -(9.8_f64).sqrt()),
         (-1.0, 0.0, -(9.8_f64).sqrt(), 0.0)
      ];
      for (kx, ky, xf, yf) in check_axis {
         let system = WaveRayPath { g: 9.8 };
         let y0 = State::new(0.0, 0.0, kx, ky);
         let mut stepper = Rk4::new(system, 0.0, y0, 1.0, 1.0);
         if stepper.integrate().is_ok() {
            let last_state = stepper.y_out().last().unwrap();
            assert!(
               (last_state.x - xf).abs() < 3.0*f64::EPSILON // super close, so I will take the values it gives as accurate
               && (last_state.y - yf).abs() < 3.0*f64::EPSILON,
               "expected xf: {}, actual: {} \nexpected yf: {}, actual: {}",
               xf, last_state.x, yf, last_state.y
            );
         } else {
            panic!("Error during ode_solvers integration")
         }
      }
   }


   #[test]
   fn test_solver() {

      // open file
      let check_file = File::open("answers.txt").expect("could not open file");
      let buf_answers = BufReader::new(check_file);
      let mut vec_answers: Vec<String> = Vec::new();
      for line in buf_answers.lines() {
         vec_answers.push(line.unwrap_or(String::from("\0")));
      }
      // get initial state
      let vec_y0 : Vec<&str> = vec_answers[1].split(" ").collect();

      // set up ode_solvers
      let system = WaveRayPath{ g: 9.8 };
      let y0 = State::new(vec_y0[1].parse().unwrap(), vec_y0[2].parse().unwrap(), vec_y0[3].parse().unwrap(), vec_y0[4].parse().unwrap()); // (x, y, kx, ky)

      let t0 = vec_y0[0].parse().unwrap();
      let tf = 10.0;
      let step_size = 1.0;

      let mut stepper = Rk4::new(system, t0, y0, tf, step_size);
      let res = stepper.integrate();

          // Handle result
      match res {
         Ok(stats) => {

            // write file
            let y = stepper.y_out();
            
            let mut file = File::create("test.txt").expect("could not open file");
            writeln!(&mut file, "t x y kx ky").expect("could not write to file");
            for (i, x) in stepper.x_out().iter().enumerate() {
               write!(&mut file, "{x} ").expect("could not write to file");
               for elem in y[i].iter() {
                  write!(&mut file, "{elem} ").expect("could not write to file");
               }
               writeln!(&mut file, " ").expect("could not write to file");
            }

            // read written file
            let check_file = File::open("test.txt").expect("could not open file");
            let buf_answers = BufReader::new(check_file);
            let mut vec_results: Vec<String> = Vec::new();
            for line in buf_answers.lines() {
               vec_results.push(line.unwrap_or(String::from("\0")));
            }

            // check to see if equal (todo add epsilon so numbers can be slighlty off)
            for (i, line) in vec_results.iter().enumerate() {
               if i == 0 {
                  continue;
               }
               let ans: Vec<&str> = vec_answers[i].split_whitespace().collect();
               let check: Vec<&str> = line.split_whitespace().collect();
               for j in 0..5 {
                  let val_f64: f64 = check[j].parse().unwrap();
                  let ans_f64: f64 = ans[j].parse().unwrap();
                  assert!((val_f64 - ans_f64).abs() < 1.0e-13, "expected value: {}, actual value: {}", ans_f64, val_f64); // checked against this website: https://www.mathstools.com/section/main/runge_kutta_calculator
               }
            }
         },
         Err(_) => println!("An error occured."),
      }
   }

}
/// This function takes in the states and returns group velocity:
/// 
/// returns simple case for now
/// 
/// FIXME: if k is 0, returns inf. this may cause problems?
 pub fn group_velocity(k: f64) -> f64 {
    let g = 9.8; // relocate this?
    (g/k).sqrt()
 }

 /// Takes current state and calculates derivatives
 /// 
 /// returns the odes
 pub fn odes(kx: f64, ky: f64) -> (f64, f64, f64, f64) {

    let k_mag = (kx*kx + ky*ky).sqrt();
    let k_dir = ky.atan2(kx);

    let cg = group_velocity(k_mag);
    let cgx = cg * k_dir.cos();
    let cgy = cg * k_dir.sin();

    let dxdt = cgx;
    let dydt = cgy;

    let dkxdt = 0.0;
    let dkydt = 0.0;

    (dxdt, dydt, dkxdt, dkydt)
 }

#[cfg(test)]
mod tests {
    use crate::{group_velocity, odes};

   // testing group velocity function against values generated by wolfram alpha
    #[test]
    fn test_group_velocity() {
      let results = [
         (1.0, 3.1305),
         (3.0, 1.80739),
         (5.0, 1.4),
         (10.0, 0.989949)
      ];
      for (k, ans) in results {
         assert!((group_velocity(k) - ans).abs() < 1.0e-4, "k: {}, ans: {}", k, ans);
      } 
    }

       // testing ode on simple cases worked out by hand
   #[test]
   fn test_odes() {
      let results = [
         // (kx, ky, dxdt, dydt)
         (1.0, 0.0, 3.13050, 0.0),
         (0.0, 1.0, 0.0, 3.13050),
         (-1.0, 0.0, -3.13050, 0.0),
         (0.0, -1.0, 0.0, -3.13050),
      ];
      for (kx, ky, ans_dxdt, ans_dydt) in results {
         let (dxdt, dydt, _, _) = odes(kx, ky);
         assert!(
            (ans_dxdt - dxdt).abs() < 1.0e-4
            && (ans_dydt -dydt).abs() < 1.0e-4,
            "ans_dxdt: {}, ans_dydt: {}, dxdt: {}, dydt: {}, kx: {}, ky: {}",
            ans_dxdt, ans_dydt, dxdt, dydt, kx, ky
         );
      }
   }

}

